admins
create table public.admins (
  id uuid not null default extensions.uuid_generate_v4 (),
  user_id uuid not null,
  created_by uuid null,
  permissions text[] null default array['read'::text, 'write'::text],
  created_at timestamp with time zone null default now(),
  constraint admins_pkey primary key (id),
  constraint admins_user_id_key unique (user_id),
  constraint admins_created_by_fkey foreign KEY (created_by) references users (id),
  constraint admins_user_id_fkey foreign KEY (user_id) references users (id) on delete CASCADE
) TABLESPACE pg_default;

chat_sessions
create table public.chat_sessions (
  id uuid not null default extensions.uuid_generate_v4 (),
  user_id uuid not null,
  topic_id character varying(100) not null,
  messages text not null default ''::text,
  phase character varying(50) null default 'session'::character varying,
  message_count integer null default 0,
  last_message_at timestamp with time zone null default now(),
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint chat_sessions_pkey primary key (id),
  constraint chat_sessions_user_id_topic_id_key unique (user_id, topic_id),
  constraint unique_user_topic unique (user_id, topic_id),
  constraint chat_sessions_user_id_fkey foreign KEY (user_id) references users (id) on delete CASCADE,
  constraint chat_message_count_positive check ((message_count >= 0)),
  constraint chat_sessions_phase_check check (
    (
      (phase)::text = any (
        (
          array[
            'session'::character varying,
            'playtime'::character varying,
            'assignment'::character varying,
            'feedback'::character varying
          ]
        )::text[]
      )
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_chat_sessions_user on public.chat_sessions using btree (user_id) TABLESPACE pg_default;

create index IF not exists idx_chat_sessions_user_topic on public.chat_sessions using btree (user_id, topic_id) TABLESPACE pg_default;

create index IF not exists idx_chat_sessions_last_message on public.chat_sessions using btree (last_message_at) TABLESPACE pg_default;

create index IF not exists idx_chat_sessions_phase on public.chat_sessions using btree (phase) TABLESPACE pg_default;

create index IF not exists idx_chat_sessions_updated_at on public.chat_sessions using btree (updated_at desc) TABLESPACE pg_default;

create trigger update_chat_sessions_updated_at BEFORE
update on chat_sessions for EACH row
execute FUNCTION update_updated_at_column ();

learning_analytics
create table public.learning_analytics (
  id uuid not null default extensions.uuid_generate_v4 (),
  user_id uuid not null,
  topic_id character varying(100) not null,
  time_spent_seconds integer null default 0,
  messages_sent integer null default 0,
  hints_requested integer null default 0,
  attempts_made integer null default 0,
  errors_encountered integer null default 0,
  session_date date null default CURRENT_DATE,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint learning_analytics_pkey primary key (id),
  constraint learning_analytics_user_id_topic_id_session_date_key unique (user_id, topic_id, session_date),
  constraint learning_analytics_user_id_fkey foreign KEY (user_id) references users (id) on delete CASCADE,
  constraint analytics_positive_values check (
    (
      (time_spent_seconds >= 0)
      and (messages_sent >= 0)
      and (hints_requested >= 0)
      and (attempts_made >= 0)
      and (errors_encountered >= 0)
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_learning_analytics_user on public.learning_analytics using btree (user_id) TABLESPACE pg_default;

create index IF not exists idx_learning_analytics_topic on public.learning_analytics using btree (topic_id) TABLESPACE pg_default;

create index IF not exists idx_learning_analytics_date on public.learning_analytics using btree (session_date) TABLESPACE pg_default;

create trigger update_learning_analytics_updated_at BEFORE
update on learning_analytics for EACH row
execute FUNCTION update_updated_at_column ();

password_reset_tokens
create table public.password_reset_tokens (
  id uuid not null default extensions.uuid_generate_v4 (),
  user_id uuid not null,
  token character varying(255) not null,
  expires_at timestamp with time zone not null,
  used_at timestamp with time zone null,
  created_at timestamp with time zone null default now(),
  constraint password_reset_tokens_pkey primary key (id),
  constraint password_reset_tokens_token_key unique (token),
  constraint password_reset_tokens_user_id_fkey foreign KEY (user_id) references users (id) on delete CASCADE,
  constraint token_not_expired check ((expires_at > created_at))
) TABLESPACE pg_default;

create index IF not exists idx_password_reset_tokens_user on public.password_reset_tokens using btree (user_id) TABLESPACE pg_default;

create index IF not exists idx_password_reset_tokens_token on public.password_reset_tokens using btree (token) TABLESPACE pg_default;

create index IF not exists idx_password_reset_tokens_expires on public.password_reset_tokens using btree (expires_at) TABLESPACE pg_default;

progress
create table public.progress (
  id uuid not null default extensions.uuid_generate_v4 (),
  user_id uuid not null,
  topic_id character varying(100) not null,
  status character varying(50) null default 'not_started'::character varying,
  phase character varying(50) null default 'session'::character varying,
  current_task integer null default 0,
  total_tasks integer null default 0,
  assignments_completed integer null default 0,
  hints_used integer null default 0,
  concept_revealed boolean null default false,
  saved_code text null default ''::text,
  current_outcome_index integer null default 0,
  started_at timestamp with time zone null,
  completed_at timestamp with time zone null,
  last_accessed timestamp with time zone null default now(),
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint progress_pkey primary key (id),
  constraint progress_user_id_topic_id_key unique (user_id, topic_id),
  constraint progress_user_id_fkey foreign KEY (user_id) references users (id) on delete CASCADE,
  constraint progress_hints_positive check ((hints_used >= 0)),
  constraint progress_task_bounds check (
    (
      (current_task >= 0)
      and (current_task <= total_tasks)
    )
  ),
  constraint progress_status_check check (
    (
      (status)::text = any (
        (
          array[
            'not_started'::character varying,
            'in_progress'::character varying,
            'completed'::character varying,
            'locked'::character varying
          ]
        )::text[]
      )
    )
  ),
  constraint progress_outcome_positive check ((current_outcome_index >= 0)),
  constraint progress_phase_check check (
    (
      (phase)::text = any (
        (
          array[
            'session'::character varying,
            'playtime'::character varying,
            'assignment'::character varying,
            'feedback'::character varying,
            'completed'::character varying
          ]
        )::text[]
      )
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_progress_user on public.progress using btree (user_id) TABLESPACE pg_default;

create index IF not exists idx_progress_user_topic on public.progress using btree (user_id, topic_id) TABLESPACE pg_default;

create index IF not exists idx_progress_status on public.progress using btree (status) TABLESPACE pg_default;

create index IF not exists idx_progress_phase on public.progress using btree (phase) TABLESPACE pg_default;

create index IF not exists idx_progress_last_accessed on public.progress using btree (last_accessed) TABLESPACE pg_default;

create index IF not exists idx_progress_updated on public.progress using btree (updated_at) TABLESPACE pg_default;

create trigger update_progress_updated_at BEFORE
update on progress for EACH row
execute FUNCTION update_updated_at_column ();

progress_backup
create table public.progress_backup_comprehensive (
  id uuid null,
  user_id uuid null,
  topic_id character varying(100) null,
  status character varying(50) null,
  phase character varying(50) null,
  current_task integer null,
  total_tasks integer null,
  assignments_completed integer null,
  hints_used integer null,
  concept_revealed boolean null,
  saved_code text null,
  current_outcome_index integer null,
  started_at timestamp with time zone null,
  completed_at timestamp with time zone null,
  last_accessed timestamp with time zone null,
  created_at timestamp with time zone null,
  updated_at timestamp with time zone null
) TABLESPACE pg_default;

user_sessions
create table public.user_sessions (
  id uuid not null default extensions.uuid_generate_v4 (),
  user_id uuid not null,
  token text not null,
  expires_at timestamp with time zone not null,
  last_accessed timestamp with time zone null default now(),
  ip_address inet null,
  user_agent text null,
  created_at timestamp with time zone null default now(),
  refresh_token text null,
  refresh_expires_at timestamp with time zone null,
  constraint user_sessions_pkey primary key (id),
  constraint user_sessions_token_key unique (token),
  constraint user_sessions_user_id_fkey foreign KEY (user_id) references users (id) on delete CASCADE,
  constraint session_not_expired check ((expires_at > created_at))
) TABLESPACE pg_default;

create index IF not exists idx_user_sessions_user on public.user_sessions using btree (user_id) TABLESPACE pg_default;

create index IF not exists idx_user_sessions_expires on public.user_sessions using btree (expires_at) TABLESPACE pg_default;

create index IF not exists idx_user_sessions_token on public.user_sessions using btree (token) TABLESPACE pg_default;

create index IF not exists idx_user_sessions_refresh_token on public.user_sessions using btree (refresh_token) TABLESPACE pg_default;


users
create table public.users (
  id uuid not null default extensions.uuid_generate_v4 (),
  username character varying(50) not null,
  email character varying(255) not null,
  name character varying(100) not null,
  password text not null,
  has_access boolean null default false,
  access_expires_at timestamp with time zone null,
  email_verified boolean null default false,
  last_login timestamp with time zone null,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  security_question text null,
  security_answer text null,
  constraint users_pkey primary key (id),
  constraint users_email_key unique (email),
  constraint users_username_key unique (username),
  constraint users_email_format check (
    (
      (email)::text ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'::text
    )
  ),
  constraint users_name_length check ((length((name)::text) >= 2)),
  constraint users_username_length check ((length((username)::text) >= 3))
) TABLESPACE pg_default;

create index IF not exists idx_users_active_users on public.users using btree (id, has_access) TABLESPACE pg_default
where
  (has_access = true);

create index IF not exists idx_users_recent_login on public.users using btree (last_login) TABLESPACE pg_default
where
  (last_login is not null);

create index IF not exists idx_users_temporary_access on public.users using btree (access_expires_at) TABLESPACE pg_default
where
  (access_expires_at is not null);

create index IF not exists idx_users_email on public.users using btree (email) TABLESPACE pg_default;

create index IF not exists idx_users_username on public.users using btree (username) TABLESPACE pg_default;

create index IF not exists idx_users_last_login on public.users using btree (last_login) TABLESPACE pg_default;

create trigger update_users_updated_at BEFORE
update on users for EACH row
execute FUNCTION update_updated_at_column ();

user_comprehensive
create table public.users_backup_comprehensive (
  id uuid null,
  username character varying(50) null,
  email character varying(255) null,
  name character varying(100) null,
  password text null,
  has_access boolean null,
  access_expires_at timestamp with time zone null,
  email_verified boolean null,
  last_login timestamp with time zone null,
  created_at timestamp with time zone null,
  updated_at timestamp with time zone null,
  security_question text null,
  security_answer text null
) TABLESPACE pg_default;